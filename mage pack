local HeadSize = 6.3
local IsDisabled = false -- Set to false to enable the script by default
local IsTeamCheckEnabled = false
local HomingRadius = 10
local MaxDistance = 500
local IgnoreTransparentWalls = false
local TransparencyThreshold = 0.5 -- For wall transparency detection
local ImportantBodyParts = {"Head", "HumanoidRootPart"} -- Add more body parts if needed

-- Table to store tracked players and their hitboxes
local trackedPlayers = {}

-- Create a transparent hitbox for each player's head
local function createHeadHitbox(player)
    local character = player.Character
    if not character then return end

    local head = character:FindFirstChild("Head")
    if not head then return end

    -- Create the hitbox part
    local hitbox = Instance.new("Part")
    hitbox.Name = "HeadHitbox"
    hitbox.Size = Vector3.new(HeadSize, HeadSize, HeadSize)
    hitbox.Transparency = 1 -- Fully transparent
    hitbox.CanCollide = false -- No physical collision
    hitbox.Anchored = true -- Anchored so it doesn't fall or move
    hitbox.Parent = workspace

    -- Store the hitbox and character for tracking
    trackedPlayers[player] = {
        character = character,
        hitbox = hitbox,
        head = head
    }
end

-- Check if an object should block a shot based on material and transparency
local function isWall(hitInstance)
    -- Check if the hit instance has transparency or is part of a material that should block shots
    local hitTransparency = hitInstance.Transparency
    local hitMaterial = hitInstance.Material

    -- List of materials that should not block shots (you can adjust this list)
    local nonBlockingMaterials = {
        Enum.Material.Glass,
        Enum.Material.ForceField,
        Enum.Material.Plastic -- Optional, depending on your needs
    }

    -- Return true if the material or transparency indicates it's a blocking object
    if hitTransparency < TransparencyThreshold and not table.find(nonBlockingMaterials, hitMaterial) then
        return true
    end
    return false
end

-- Perform multiple raycasts to improve the wall check accuracy
local function performWallCheck()
    local localPlayer = game:GetService('Players').LocalPlayer
    if not localPlayer then return end

    local character = localPlayer.Character
    local head = character and character:FindFirstChild("Head")
    if not head then return end

    for _, player in ipairs(game:GetService('Players'):GetPlayers()) do
        if player ~= localPlayer and (not IsTeamCheckEnabled or player.Team ~= localPlayer.Team) then
            local data = trackedPlayers[player]
            if data and data.hitbox then
                -- Improved check for multiple body parts
                for _, partName in ipairs(ImportantBodyParts) do
                    local targetPart = data.character:FindFirstChild(partName)
                    if targetPart then
                        local rayOrigin = head.Position
                        local rayDirection = (targetPart.Position - rayOrigin).Unit * MaxDistance

                        -- Raycast to check for walls
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterDescendantsInstances = {localPlayer.Character}
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

                        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

                        if raycastResult then
                            local hitInstance = raycastResult.Instance
                            if isWall(hitInstance) then
                                print(player.Name .. " is behind a wall.")
                            else
                                print(player.Name .. " is hittable!")
                                -- Stop further checks once a hittable part is found
                                break
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Listen for when a player joins or respawns and track them
local function onPlayerAdded(player)
    player.CharacterAdded:Connect(function(character)
        wait(1) -- Wait for character to fully load
        createHeadHitbox(player)
    end)
end

-- Apply to existing players
for _, player in pairs(game:GetService('Players'):GetPlayers()) do
    if player.Character then
        createHeadHitbox(player)
    end
end

-- Apply to new players
game:GetService('Players').PlayerAdded:Connect(onPlayerAdded)

-- Continuously update player hitboxes using Heartbeat
game:GetService("RunService").Heartbeat:Connect(function()
    for player, data in pairs(trackedPlayers) do
        if data.character and data.head and data.hitbox then
            -- Update the hitbox position to follow the head
            data.hitbox.CFrame = data.head.CFrame
        else
            trackedPlayers[player] = nil -- Clean up if character is no longer available
        end
    end
end)

-- Core logic in RenderStepped for continuous wall check
game:GetService('RunService').RenderStepped:Connect(function()
    if not IsDisabled then
        performWallCheck() -- Continuously check for walls and hittable targets
    end
end)

print("Enhanced HBE script with better wall check successfully executed!")
